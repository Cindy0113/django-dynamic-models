# django-dynamic-models


## Overview

Dynamic Django models allow users to define, edit, and populate their own database tables and apply runtime schema changes to the database. `django-dynamic-models` is loosely based on the [runtime dynamic models](https://dynamic-models.readthedocs.io/en/latest/) talk from DjangoCon 2011. The basic concept involves around dynamic class declaration using the built-in `type` function. We use `type` to dynamically declare new Django models at runtime, and it is the goal of this project to provide a simple API to allow developers to get started with runtime dynamic models quickly.

This package provides abstract models to help Django developers quickly implement dynamic runtime models for their specific use case while the runtime schema changes and Django's model registry are handled automatically. The schema changes are applied in pure Django, *without* the migrations framework, so none of your dynamic models will affect your migrations files at all.

## Installation

Install `django-dynamic-models` from PyPi with:

```python
pip install django-dynamic-models
```

Then, add `'dynamic_models'` and `django.contrib.contenttypes` to `INSTALLED_APPS`.
> **Note**: 
> 
> Django's Content Types app is currently required, although this dependency may possibly removed in the future.

```python
INSTALLED_APPS = [
    ...
    'dynamic_models',
    'django.contrib.conttenttypes'
]
```

## Usage

To begin, simply subclass `AbstractModelSchema` and `AbstractFieldSchema` from `dynamic_models.models`. The abstract models will still work if no additional fields are provided. The simplest way to get started with dynamic models would be to add subclasses to your app's `models.py`, and run migrations. Then, new models can be created dynamically by creating instances of model schema and field schema models.

```python
from dynamic_models.models import AbstractModelSchema, AbstractFieldSchema

# These can be named anything you want, but the following examples assume these
# models exist in your app's models.py
class ModelSchema(AbstractModelSchema):
    pass

class FieldSchema(AbstractFieldSchema):
    pass
```

Now, run the migration commands:
```
$ python manage.py makemigrations
> ... making migrations ...

$ python manage.py migrate
> ... migrating ...
```

### Creating dynamic models

Creating a dynamic model is as simple as creating a new instance of your concrete model schema class. `AbstractModelSchema` provides a single public field: `name`. The `name` field will be used to generate the class name and the name of the database table. Once created, the `as_model` method can be used to retreive the dynamic model class.

Great care has been taken to ensure that the model returned by this method is the most up to date, even if the model schema has since been changed in the database. If you encounter any bugs where you receive an outdated model, from this method, please log and issue with as much information as possible.

>**Note**:
>
>The `name` field has `unique=True` by default to help enforce unique table names generated by the `AbstracModelSchema` instance. To use a different table naming scheme, the `db_table` (and probably `model_name`) properties should be overridden. Care should be taken that it is not possible to generate the same `db_table` from different instances of `AbstractModelSchema`. 

```python
from django.db import models

# The default model_name will be `Car` and the default table_name 'myapp_car'
# Take a look at the source code to see how the table name and model name are
# derived from the name value
car_schema = ModelSchema.objects.create(name='car')
Car = car_schema.as_model()
assert issubclass(Car, models.Model)

# The dynamic model can now be used to create Car instances
instance = Car.objects.create()
assert instance.pk is not None
```

### Adding fields

Creating field schema to add to models is quite similar to creating dynamic models. `AbstractFieldSchema` provides two fields, `name` and `data_type`, and they are responsible for naming the database column and choosing which Django field to add to the dynamic model.

> **Note**: The value of `data_type` is not editable while data migrations are not supported.

Currently supported data types are returned by the `get_data_types` class method. Supported data types and their corresponding fields are listed below:

| Data Type | Django Field |
|:---------:|:------------:|
| character | CharField    |
| text      | TextField    |
| integer   | IntegerField |
| float     | FloatField   |
| boolean   | BooleanField |
| date      | DateTimeField|

```python
car_model_schema = ModelSchema.objects.create(name='car')

# The color field is still completely independent of the Car model, and it has
# not been added to any database tables 
color_field_schema = FieldSchema.objects.create(name='color', data_type='character')

# Like normal CharFields, a max_length must be defined for the character data type
# Add a field to a dynamic model with the 'add_field' method
color = model_schema.add_field(
    color_field_schema,
    null=False,
    unique=False,
    max_length=16
)
# The field's model and field schema are available through 'model_schema' and
# 'field_schema' properties
assert color.field_schema == color_field_schema
assert color.model_schema == car_model_schema

# Now the new field can be used as you normally would in Django. Be sure to grab
# the lastest version of the dynamic model with as_model()
Car = model_schema.as_model()
red_car = Car.objects.create(color='red')
assert red_car.pk is not None
assert red_car.color == 'red'

# This will raise an error because the 'color' field is required
another_car = Car.objects.create()

# Change the schema with 'update_field' to allow null
# Note: null columns cannot currently be changes to not null
car_model_schema.update_field(color_field_schema, null=True)

# Remove a field from the model
car_model_schema.remove_field(color_field_schema)
```

## Support
Official version support will be tested and defined pre-release.