# django-dynamic-models

**NOTE: WORK IN PROGRESS**

This is a work in progress. All code is subject to change and is not guaranteed to work properly. Check out the `develop` branch to view progress. Suggestions and feedback are encouraged in the meantime! The package is not yet available on PyPi.


## Overview

Dynamic Django models allow users to define, edit, and populate their own database tables and apply runtime schema changes to the database. `django-dynamic-models` is based on the [runtime dynamic models](https://dynamic-models.readthedocs.io/en/latest/) talk from DjangoCon 2011. The basic concept revolves around dynamic class declaration using the built-in `type` function to declare new Django models at runtime.

This package provides abstract models to help Django developers quickly implement dynamic runtime models for their specific use case while the runtime schema changes are handled behind the scenes.

## Installation

Install `django-dynamic-models` from PyPi with:

```python
pip install django-dynamic-models
```

Then, add `'dynamic_models'` to `INSTALLED_APPS` and run the commands `makemigrations` and `migrate`.
> **Note**: 
> 
> Django's Content Types app is currently required.

```python
INSTALLED_APPS = [
    ...
    'dynamic_models',
    'django.contrib.conttenttypes'
]
```

## Usage

To begin, simply import and subclass `AbstractModelSchema` and `AbstractFieldSchema` from `dynamic_models.models`. The abstract models will still work if no additional fields are provided, and multiple subclasses of the abstract models can work together within the same app.

The simplest way to get started with the most basic functionality would be to add subclasses to your app's `models.py`, and run migrations.

```python
from dynamic_models.models import AbstractModelSchema, AbstractFieldSchema

# These can be named anything you want
class ModelSchema(AbstractModelSchema):
    pass

class FieldSchema(AbstractFieldSchema):
    pass
```

Now, run the migration commands:
```
$ python manage.py makemigrations
> ... making migrations ...

$ python manage.py migrate
> ... migrating ...
```

### Creating dynamic models

Creating a dynamic model is as simple as creating a new instance of your concrete model schema class. `AbstractModelSchema` provides two fields, `name` and `modified` required to generate the new model class.

>**Note**:
>
>The `name` field has `unique=True` by default to help enforce unique table names generated by the `AbstracModelSchema` instance. To use a different table naming scheme, the `table_name` (and probably `model_name`) properties should be overridden. Care should be taken that it is not possible to generate the same `table_name` from different instances of `AbstractModelSchema`. 

```python
# The default model_name will be `MyModel` and the default table_name 'myapp_mymodel'
from django.db import models
model_schema = ModelSchema.objects.create(name='car')
MyModel = model_schema.get_dynamic_model()
assert issubclass(MyModel, models.Model)

#The dynamic model can now be used
instance = MyModel.objects.create()
assert instance.pk is not None
```

### Creating field schema

Creating field schema to add to models is quite similar to creating dynamic_models. Let's create a standalone "name" field to add to our new model. Field schema are defined independently of the dynamic models. The [`AbstractFieldSchema`](docs/abstract-field-schema.md) class provides two fields: `name` and `data_type`. Then, they can be added to concrete `ModelSchema` instances with the `add_field` method.

```python
from dynamic_models.models import DataTypes

car_model_schema = ModelSchema.objects.create(name='car')
color_field = FieldSchema.objects.create(name='color', data_type=DataTypes.char)

# Like normal CharFields, a max_length must be defined for the char data type
color = model_schema.add_field(
    color_field,
    required=True,
    unique=False,
    max_length=16
)
# The field's model and field schema are available through 'model' and 'field'
# respectively
assert color.field == color_field and color.model == car_model_schema

# Now the new field can be used as you normally would in Django
Car = model_schema.get_dynamic_model()
red_car = Car.objects.create(color='red')
assert red_car.pk is not None

# This will raise an error because the 'color' field is required
another_car = Car.objects.create()
```

## Support
Official version support will be tested and defined pre-release.